package tk.azertyfun.dcputoolchain.emulator;

public class EDC extends DCPUHardware {
	public static final int CELL_SIZE = 1;
	public static final int MEDIA_TYPE = 00;
	public static final int FIRMWARE_VERSION = 0;
	public static final int TEXT_CELL_LINE_COUNT = 2;
	public static final int TEXT_CELL_COLUMN_COUNT = 8; //Must be a multiple of 4

	public static final int TYPE = 0x70E3E4FF, REVISION = (CELL_SIZE << 10) & 0b11 | (MEDIA_TYPE << 8) | (FIRMWARE_VERSION << 7) | ((TEXT_CELL_LINE_COUNT - 1) << 5) | (TEXT_CELL_COLUMN_COUNT / 4), MANUFACTURER = 0x59EA5742;

	private char[] ram = new char[0x0400];
	private char cursor_address = 0;

	private Texture texture;

	public static final char defaultFont[] = new char[] {
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0000, 0x0000, 0x0000, 0x0000,
			0x0, 0x0, 0x0, 0x0,
			0x200, 0x204, 0x204, 0x200,
			0x500, 0x50a, 0x0, 0x0,
			0x50a, 0x51f, 0xf8a, 0x50a,
			0xf04, 0x285, 0xa0e, 0x794,
			0x800, 0x40a, 0x104, 0x8a,
			0x300, 0x289, 0xa82, 0xb09,
			0x200, 0x204, 0x0, 0x0,
			0x400, 0x104, 0x102, 0x404,
			0x100, 0x404, 0x408, 0x104,
			0x200, 0x715, 0x71f, 0x215,
			0x200, 0x204, 0x21f, 0x204,
			0x0, 0x0, 0x200, 0x104,
			0x0, 0x0, 0x1f, 0x0,
			0x0, 0x0, 0x0, 0x200,
			0x0, 0x410, 0x104, 0x1,
			0x700, 0xc91, 0x995, 0x711,
			0x200, 0x206, 0x204, 0x704,
			0x700, 0x811, 0x208, 0xf82,
			0xf80, 0x208, 0x808, 0x711,
			0x400, 0x50c, 0xf89, 0x408,
			0xf80, 0x81, 0x80f, 0x711,
			0x600, 0x82, 0x88f, 0x711,
			0xf80, 0x411, 0x104, 0x102,
			0x700, 0x891, 0x88e, 0x711,
			0x700, 0x891, 0x81e, 0x308,
			0x0, 0x306, 0x300, 0x6,
			0x300, 0x6, 0x306, 0x104,
			0x400, 0x104, 0x101, 0x404,
			0x0, 0xf80, 0xf80, 0x0,
			0x100, 0x404, 0x410, 0x104,
			0x700, 0x811, 0x208, 0x200,
			0x700, 0x811, 0xa92, 0x715,
			0x200, 0x88a, 0xf91, 0x891,
			0x780, 0x891, 0x88f, 0x791,
			0xf00, 0x81, 0x81, 0xf01,
			0x780, 0x891, 0x891, 0x791,
			0xf80, 0x81, 0x9f, 0xf81,
			0xf80, 0x81, 0x9f, 0x81,
			0xf00, 0x81, 0x89d, 0x711,
			0x880, 0x891, 0x89f, 0x891,
			0x700, 0x204, 0x204, 0x704,
			0xe00, 0x408, 0x408, 0x20a,
			0x880, 0x289, 0x283, 0x889,
			0x80, 0x81, 0x81, 0xf81,
			0x880, 0xa9b, 0x895, 0x891,
			0x880, 0x991, 0xc95, 0x891,
			0x700, 0x891, 0x891, 0x711,
			0x780, 0x891, 0x8f, 0x81,
			0x700, 0x891, 0xa91, 0xb09,
			0x780, 0x891, 0x28f, 0x889,
			0xf00, 0x81, 0x80e, 0x790,
			0xf80, 0x204, 0x204, 0x204,
			0x880, 0x891, 0x891, 0x711,
			0x880, 0x891, 0x891, 0x20a,
			0x880, 0x891, 0x891, 0x515,
			0x880, 0x511, 0x504, 0x891,
			0x880, 0x891, 0x20a, 0x204,
			0xf80, 0x410, 0x104, 0xf81,
			0x10e, 0x102, 0x102, 0x702,
			0x0, 0x101, 0x404, 0x10,
			0x700, 0x408, 0x408, 0x708,
			0x200, 0x88a, 0x0, 0x0,
			0x0, 0x0, 0x0, 0xf80,
			0x202, 0x8, 0x0, 0x0,
			0x0, 0x700, 0xf10, 0x711,
			0x80, 0x681, 0x893, 0x791,
			0x0, 0x700, 0x91, 0x711,
			0x800, 0xb10, 0x899, 0x711,
			0x0, 0x700, 0x791, 0x701,
			0x600, 0x112, 0x107, 0x102,
			0x0, 0xf00, 0xf11, 0x710,
			0x80, 0x81, 0x88f, 0x891,
			0x0, 0x4, 0x206, 0x704,
			0x0, 0x4, 0x206, 0x105,
			0x100, 0x902, 0x30a, 0x90a,
			0x300, 0x204, 0x204, 0x704,
			0x0, 0x0, 0xa8b, 0x895,
			0x0, 0x680, 0x893, 0x891,
			0x0, 0x700, 0x891, 0x711,
			0x0, 0x780, 0x791, 0x81,
			0x0, 0xc96, 0x81e, 0x810,
			0x0, 0x98d, 0x81, 0x81,
			0x0, 0x700, 0x701, 0x790,
			0x100, 0x382, 0x102, 0x612,
			0x0, 0x0, 0x891, 0xb19,
			0x0, 0x880, 0x891, 0x20a,
			0x0, 0x0, 0x891, 0x515,
			0x0, 0x880, 0x20a, 0x88a,
			0x0, 0x880, 0xf11, 0x610,
			0x0, 0xf80, 0x208, 0xf82,
			0x400, 0x204, 0x202, 0x404,
			0x200, 0x204, 0x204, 0x204,
			0x100, 0x204, 0x208, 0x104,
			0xb00, 0x9, 0x0, 0x0,
			0x0000, 0x0000, 0x0000, 0x0000
	};

	protected EDC(String id) {
		super(TYPE, REVISION, MANUFACTURER);
		this.id = id;
	}

	@Override
	public void interrupt() {
		int a = dcpu.registers[0];
		int b = dcpu.registers[1];
		switch(a) {
			case 0x0001: //CURSOR_ADDRESS
				if(b > 0x3FF)
					break;
				cursor_address = (char) b;
				break;
			case 0x0002: //RESET_CONTROLW
				if((b & 1) == 1) {
					clearScreen();
				}
				if(((b >> 1) & 1) == 1) {
					cursor_address = 0;
				}
				break;
			case 0x0003: //WRITE_DISPLAY
				//TODO: Test custom font support

				boolean advance_cursor = (b >> 7) == 1 ? false : true;
				char c = (char) (b & 0b1111111);
				if(c > 0x80) {
					c |= 0b10000000; //Eighth bit determines wether or not to use custom font glyph
				}

				ram[cursor_address] = (char) c;

				if(advance_cursor)
					cursor_address++;
				break;
			case 0xFFFE: //QUERY_DISPLAY
				//TODO
				break;
			case 0xFFFF: //RESTART_DISPLAY
				powerOff();
				powerOn();
				break;
		}
	}

	private void clearScreen() {
		for(int i = 0; i < 0x0200; ++i) {
			ram[i] = 0;
		}
	}

	@Override
	public void tick60hz() {

	}

	@Override
	public void powerOn() {
		for(int i = 0; i < 0x0400; ++i) {
			ram[i] = 0;
		}
		cursor_address = 0;
	}

	public void render() {
		Texture.Color colors[][] = new Texture.Color[6 * TEXT_CELL_COLUMN_COUNT][8 * TEXT_CELL_LINE_COUNT];
		int pos = 0;
		for(int y = 0; y < TEXT_CELL_LINE_COUNT; ++y) {
			for(int x = 0; x < TEXT_CELL_COLUMN_COUNT; ++x) {
				char character = (char) (ram[pos] & 0b1111111);
				boolean customFont = ram[pos] >> 7 == 1 ? true : false;
				char fontChar[] = new char[] {font(character * 4, customFont), font(character * 4 + 1, customFont), font(character * 4 + 2, customFont), font(character * 4 + 3, customFont), font(character * 4 + 4, customFont), font(character * 4 + 5, customFont)};

				for(int i = 0; i < 8; ++i) {
					//int word = fontChar[((i >= 2) ? 1 : 0) * 1]; //java, plz, why can't you cast boolean to int ?
					int word = 0;
					switch(i) {
						case 0:
						case 1:
							word = fontChar[0];
							break;
						case 2:
						case 3:
							word = fontChar[1];
							break;
						case 4:
						case 5:
							word = fontChar[2];
							break;
						case 6:
						case 7:
							word = fontChar[3];
							break;
					}
					int word_row = (word >> ((i % 2) == 0 ? 0 : 7)) & 0b11111;
					for(int j = 0; j < 6; ++j) {
						int pixel = (word_row >> j) & 1;
						int px = x * 6 + j;
						int py = y * 8 + i;
						if(pixel == 1) {
							colors[px][py] = new Texture.Color(0, 0, 0);
						} else {
							colors[px][py] = new Texture.Color(1, 1, 1);
						}
					}
				}
				pos++;
			}
		}

		texture = new Texture(6 * TEXT_CELL_COLUMN_COUNT, 8 * TEXT_CELL_LINE_COUNT, colors);
	}

	private char font(int f, boolean customFont) {
		if(customFont) {
			return ram[0x200 + f];
		} else {
			return defaultFont[f];
		}
	}

	public Texture getTexture() {
		return texture;
	}
}
